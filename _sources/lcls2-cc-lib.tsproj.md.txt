PLC Project (1): Library
========================

    Project root: /home/travis/build/pcdshub/lcls2-cc-lib/lcls2-cc-lib
    Project path: Library/Library.plcproj
    TMC path:     Library/Library.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         851

    Source files:
        1.) Library/Devices/ATM/ENUM_ATM_States.TcDUT
        2.) Library/Devices/ATM/FB_ATM.TcPOU
        3.) Library/Devices/ATM/FB_ATM_States.TcPOU
        4.) Library/Devices/LIC/ENUM_LIC_States.TcDUT
        5.) Library/Devices/LIC/FB_LIC.TcPOU
        6.) Library/Devices/LIC/FB_LIC_States.TcPOU
        7.) Library/Devices/PPM/ENUM_PPM_States.TcDUT
        8.) Library/Devices/PPM/FB_PPM.TcPOU
        9.) Library/Devices/PPM/FB_PPM_Gige.TcPOU
        10.) Library/Devices/PPM/FB_PPM_PowerMeter.TcPOU
        11.) Library/Devices/PPM/FB_PPM_States.TcPOU
        12.) Library/Devices/REF/FB_REF.TcPOU
        13.) Library/Devices/REF/FB_REF_Laser.TcPOU
        14.) Library/Devices/SLITS/FB_SLITS.TcPOU
        15.) Library/Devices/SLITS/FB_SLITS_POWER.TcPOU
        16.) Library/Devices/WFS/ENUM_WFS_States.TcDUT
        17.) Library/Devices/WFS/FB_WFS.TcPOU
        18.) Library/Devices/WFS/FB_WFS_States.TcPOU
        19.) Library/Devices/XPIM/ENUM_XPIM_Filters.TcDUT
        20.) Library/Devices/XPIM/ENUM_XPIM_States.TcDUT
        21.) Library/Devices/XPIM/FB_XPIM.TcPOU
        22.) Library/Devices/XPIM/FB_XPIM_FilterWheel.TcPOU
        23.) Library/Devices/XPIM/FB_XPIM_LED.TcPOU
        24.) Library/Devices/XPIM/FB_XPIM_Opal.TcPOU
        25.) Library/Devices/XPIM/FB_XPIM_States.TcPOU
        26.) Library/POUs/FB_L2SI_Flowmeter.TcPOU
        27.) Library/POUs/FB_XTES_Flowswitch.TcPOU
        28.) Library/Version/Global_Version.TcGVL

    POUs:
        1.) FB_ATM
        2.) FB_ATM_States
        3.) FB_L2SI_Flowmeter
        4.) FB_LIC
        5.) FB_LIC_States
        6.) FB_PPM
        7.) FB_PPM_Gige
        8.) FB_PPM_PowerMeter
        9.) FB_PPM_States
        10.) FB_REF
        11.) FB_REF_Laser
        12.) FB_SLITS
        13.) FB_SLITS_POWER
        14.) FB_WFS
        15.) FB_WFS_States
        16.) FB_XPIM
        17.) FB_XPIM_FilterWheel
        18.) FB_XPIM_LED
        19.) FB_XPIM_Opal
        20.) FB_XPIM_States
        21.) FB_XTES_Flowswitch

    GVLs:
        1.) Global_Version

DUT: ENUM_ATM_States
--------------------

File: Library/Devices/ATM/ENUM_ATM_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_ATM_States :
(
    Unknown := 0,
    OUT := 1,
    TARGET1 := 2,
    TARGET2 := 3,
    TARGET3 := 4,
    TARGET4 := 5,
    TARGET5 := 6
);
END_TYPE
```


DUT: ENUM_LIC_States
--------------------

File: Library/Devices/LIC/ENUM_LIC_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_LIC_States :
(
    Unknown := 0,
    OUT := 1,
    MIRROR1 := 2,
    MIRROR2 := 3,
    TARGET := 4
);
END_TYPE
```


DUT: ENUM_PPM_States
--------------------

File: Library/Devices/PPM/ENUM_PPM_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_PPM_States :
(
    Unknown := 0,
    OUT := 1,
    POWERMETER := 2,
    YAG1 := 3,
    YAG2 := 4
);
END_TYPE
```


DUT: ENUM_WFS_States
--------------------

File: Library/Devices/WFS/ENUM_WFS_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_WFS_States :
(
    Unknown := 0,
    OUT := 1,
    TARGET1 := 2,
    TARGET2 := 3,
    TARGET3 := 4,
    TARGET4 := 5,
    TARGET5 := 6
);
END_TYPE
```


DUT: ENUM_XPIM_Filters
----------------------

File: Library/Devices/XPIM/ENUM_XPIM_Filters.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_Filters :
(
    Unknown := 0,
    T50 := 1,
    T25 := 2,
    T10 := 3,
    T5 := 4,
    T1 := 5,
    T100 := 6
);
END_TYPE
```


DUT: ENUM_XPIM_States
---------------------

File: Library/Devices/XPIM/ENUM_XPIM_States.TcDUT

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_States :
(
    Unknown := 0,
    OUT := 1,
    YAG := 2,
    DIAMOND := 3,
    RETICLE := 4
);
END_TYPE
```


GVL: Global_Version
-------------------

File: Library/Version/Global_Version.TcGVL

```vhdl
{attribute 'TcGenerated'}
{attribute 'no-analysis'}
// This function has been automatically generated from the project information.
VAR_GLOBAL CONSTANT
    {attribute 'const_non_replaced'}
    {attribute 'linkalways'}
    stLibVersion_lcls2_cc_lib : ST_LibVersion := (iMajor := 0, iMinor := 0, iBuild := 0, iRevision := 0, sVersion := '0.0.0');
END_VAR
```


POU: FB_ATM
-----------

File: Library/Devices/ATM/FB_ATM.TcPOU

```vhdl
FUNCTION_BLOCK FB_ATM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    stXStage: DUT_MotionStage;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    stOut: DUT_PositionState;
    stTarget1: DUT_PositionState;
    stTarget2: DUT_PositionState;
    stTarget3: DUT_PositionState;
    stTarget4: DUT_PositionState;
    stTarget5: DUT_PositionState;
    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    fbXStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_ATM_States;

    {attribute 'pytmc' := '
        pv: STC:01
        io: input
    '}
    fbThermoCouple1: FB_TempSensor;
END_VAR
fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbXStage(stMotionStage:=stXStage);
stXStage.bLimitForwardEnable := TRUE;
stXStage.bLimitBackwardEnable := TRUE;
stXStage.bHardwareEnable := TRUE;
stXStage.bPowerSelf := TRUE;
stXStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable := TRUE,
    stOut:=stOut,
    stTarget1:=stTarget1,
    stTarget2:=stTarget2,
    stTarget3:=stTarget3,
    stTarget4:=stTarget4,
    stTarget5:=stTarget5);

fbThermoCouple1();

END_FUNCTION_BLOCK
```


POU: FB_ATM_States
------------------

File: Library/Devices/ATM/FB_ATM_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_ATM_States EXTENDS FB_PositionStateBase_WithPMPS
VAR_INPUT
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_ATM_states;

    stOut: DUT_PositionState;
    stTarget1: DUT_PositionState;
    stTarget2: DUT_PositionState;
    stTarget3: DUT_PositionState;
    stTarget4: DUT_PositionState;
    stTarget5: DUT_PositionState;

    bStatesLock: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_ATM_States;
END_VAR
VAR
    bATMInit: BOOL;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 2;
    fOutDelta: LREAL := 2;
    fInVelocity: LREAL := 5;
    fOutVelocity: LREAL := 5;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bATMInit THEN
    bATMInit := TRUE;

    stOut.sName := 'OUT';
    stOut.fVelocity := fOutVelocity;
    stOut.fDelta := fOutDelta;
    stOut.fAccel := fAccel;
    stOut.fDecel := fOutDecel;
    stOut.bMoveOk := TRUE;

    stTarget1.sName := 'TARGET1';
    stTarget1.fVelocity := fInVelocity;
    stTarget1.fDelta := fInDelta;
    stTarget1.fAccel := fAccel;
    stTarget1.fDecel := fAccel;
    stTarget1.bMoveOk := TRUE;

    stTarget2.sName := 'TARGET2';
    stTarget2.fVelocity := fInVelocity;
    stTarget2.fDelta := fInDelta;
    stTarget2.fAccel := fAccel;
    stTarget2.fDecel := fAccel;
    stTarget2.bMoveOk := TRUE;

    stTarget3.sName := 'TARGET3';
    stTarget3.fVelocity := fInVelocity;
    stTarget3.fDelta := fInDelta;
    stTarget3.fAccel := fAccel;
    stTarget3.fDecel := fAccel;
    stTarget3.bMoveOk := TRUE;

    stTarget4.sName := 'TARGET4';
    stTarget4.fVelocity := fInVelocity;
    stTarget4.fDelta := fInDelta;
    stTarget4.fAccel := fAccel;
    stTarget4.fDecel := fAccel;
    stTarget4.bMoveOk := TRUE;

    stTarget5.sName := 'TARGET5';
    stTarget5.fVelocity := fInVelocity;
    stTarget5.fDelta := fInDelta;
    stTarget5.fAccel := fAccel;
    stTarget5.fDecel := fAccel;
    stTarget5.bMoveOk := TRUE;

    arrStates[1] := stOut;
    arrStates[2] := stTarget1;
    arrStates[3] := stTarget2;
    arrStates[4] := stTarget3;
    arrStates[5] := stTarget4;
    arrStates[6] := stTarget5;
END_IF

setState := enumSet;
Exec();
enumGet := getState;
enumSet := setState;

END_FUNCTION_BLOCK
```


POU: FB_L2SI_Flowmeter
----------------------

File: Library/POUs/FB_L2SI_Flowmeter.TcPOU

```vhdl
FUNCTION_BLOCK FB_L2SI_Flowmeter
VAR
    {attribute 'pytmc' := '
        pv: MA
        io: input
    '}
    fRaw AT %I*: INT;

    {attribute 'pytmc' := '
        pv: FLOW
        io: input
    '}
    fFlowRate: LREAL;
END_VAR


END_FUNCTION_BLOCK
```


POU: FB_LIC
-----------

File: Library/Devices/LIC/FB_LIC.TcPOU

```vhdl
FUNCTION_BLOCK FB_LIC
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    stOut: DUT_PositionState;
    stMirror1: DUT_PositionState;
    stMirror2: DUT_PositionState;
    stTarget1: DUT_PositionState;
    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_LIC_States;
END_VAR
fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable := TRUE,
    stOut:=stOut,
    stMirror1:=stMirror1,
    stMirror2:=stMirror2,
    stTarget1:=stTarget1);

END_FUNCTION_BLOCK
```


POU: FB_LIC_States
------------------

File: Library/Devices/LIC/FB_LIC_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_LIC_States EXTENDS FB_PositionStateBase_WithPMPS
VAR_INPUT
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_LIC_states;

    stOut: DUT_PositionState;
    stMirror1: DUT_PositionState;
    stMirror2: DUT_PositionState;
    stTarget1: DUT_PositionState;

    bStatesLock: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_LIC_States;
END_VAR
VAR
    bLICInit: BOOL;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 2;
    fOutDelta: LREAL := 2;
    fInVelocity: LREAL := 5;
    fOutVelocity: LREAL := 5;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bLICInit THEN
    bLICInit := TRUE;

    stOut.sName := 'OUT';
    stOut.fVelocity := fOutVelocity;
    stOut.fDelta := fOutDelta;
    stOut.fAccel := fAccel;
    stOut.fDecel := fOutDecel;
    stOut.bMoveOk := TRUE;

    stMirror1.sName := 'MIRROR1';
    stMirror1.fVelocity := fInVelocity;
    stMirror1.fDelta := fInDelta;
    stMirror1.fAccel := fAccel;
    stMirror1.fDecel := fAccel;
    stMirror1.bMoveOk := TRUE;

    stMirror2.sName := 'MIRROR2';
    stMirror2.fVelocity := fInVelocity;
    stMirror2.fDelta := fInDelta;
    stMirror2.fAccel := fAccel;
    stMirror2.fDecel := fAccel;
    stMirror2.bMoveOk := TRUE;

    stTarget1.sName := 'TARGET';
    stTarget1.fVelocity := fInVelocity;
    stTarget1.fDelta := fInDelta;
    stTarget1.fAccel := fAccel;
    stTarget1.fDecel := fAccel;
    stTarget1.bMoveOk := TRUE;

    arrStates[1] := stOut;
    arrStates[2] := stMirror1;
    arrStates[3] := stMirror2;
    arrStates[4] := stTarget1;
END_IF

setState := enumSet;
Exec();
enumGet := getState;
enumSet := setState;

END_FUNCTION_BLOCK
```


POU: FB_PPM
-----------

File: Library/Devices/PPM/FB_PPM.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    stOut: DUT_PositionState;
    stPower: DUT_PositionState;
    stYag1: DUT_PositionState;
    stYag2: DUT_PositionState;
    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_PPM_States;

    {attribute 'pytmc' := '
        pv: SPM
    '}
    fbPowerMeter: FB_PPM_PowerMeter;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbGige: FB_PPM_Gige;

    {attribute 'pytmc' :='
        pv: SFM
    '}
    fbFlowMeter: FB_L2SI_Flowmeter;

    {attribute 'pytmc' := '
        pv: YAG
        io: input
    '}
    fbYagThermoCouple: FB_ThermoCouple;
END_VAR
fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable:=TRUE,
    stOut:=stOut,
    stPower:=stPower,
    stYag1:=stYag1,
    stYag2:=stYag2);

fbPowerMeter();
fbGige();
fbFlowMeter();
fbYagThermoCouple();

END_FUNCTION_BLOCK
```


POU: FB_PPM_Gige
----------------

File: Library/Devices/PPM/FB_PPM_Gige.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_Gige
VAR
    iIlluminatorINT AT %Q*: INT;

    {attribute 'pytmc' := '
        pv: PWR
        field: ZNAM OFF
        field: ONAM ON
    '}
    bGigePower AT %Q*: BOOL;

    {attribute 'pytmc' := '
        pv: CIL:PCT
        EGU: %
    '}
    fIlluminatorPercent: LREAL;

    fbGetIllPercent: FB_AnalogInput;
    fbSetIllPercent: FB_AnalogOutput;

    bGigeInit: BOOL := FALSE;
END_VAR
// Turn the GigE on by default
IF NOT bGigeInit THEN
    bGigePower := TRUE;
    bGigeInit := TRUE;
END_IF

// Illuminator conversion to percentage
fbSetIllPercent(
    fReal:=fIlluminatorPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    iRaw=>iIlluminatorINT);
fbGetIllPercent(
    iRaw:=iIlluminatorINT,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    fReal=>fIlluminatorPercent);

END_FUNCTION_BLOCK
```


POU: FB_PPM_PowerMeter
----------------------

File: Library/Devices/PPM/FB_PPM_PowerMeter.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_PowerMeter
VAR
    iVoltageINT AT %I*: INT;

    {attribute 'pytmc' := '
        pv: VOLT
        io: input
        field: EGU mV
    '}
    fVoltage: LREAL;

    {attribute 'pytmc' := '
        pv: VOLT_BUFFER
        io: input
        field: EGU mV
    '}
    fVoltageBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: CALIB
        io: input
    '}
    fCalibBase: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB_BUFFER
        io: input
    '}
    fCalibBaseBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: MJ
        io: input
        field: EGU mJ
    '}
    fCalibMJ: LREAL;

    {attribute 'pytmc' := '
        pv: MJ_BUFFER
        io: input
        field: EGU mJ
    '}
    fCalibMJBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv:
        io: input
    '}
    fbThermoCouple: FB_ThermoCouple;

    {attribute 'pytmc' := '
        pv: CALIB:OFFSET
        io: io
    '}
    fCalibRelOffset: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:RATIO
        io: io
    '}
    fCalibRelRatio: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:MJ_RATIO
        io: io
    '}
    fCalibMJRatio: LREAL;

    fbGetPMVoltage: FB_AnalogInput;
    fbVoltageBuffer: FB_LREALBuffer;
    fbCalibBaseBuffer: FB_LREALBuffer;
    fbCalibMJBuffer: FB_LREALBuffer;
END_VAR
fbThermoCouple();

// Convert the terminal's integer into a value in millivolts
fbGetPMVoltage(
    iRaw := iVoltageINT,
    iTermBits := 15,
    fTermMax := 10000,
    fTermMin := 0,
    fReal => fVoltage);

// Power meter calibration
fCalibBase := (fVoltage + fCalibRelOffset) * fCalibRelRatio;
fCalibMJ := fCalibBase * fCalibMJRatio;

// Buffer the full-rate Voltage and calibrated MJ values
fbVoltageBuffer(
    bExecute := TRUE,
    fInput := fVoltage,
    arrOutput => fVoltageBuffer);
fbCalibBaseBuffer(
    bExecute := TRUE,
    fInput := fCalibBase,
    arrOutput => fCalibBaseBuffer);
fbCalibMJBuffer(
    bExecute := TRUE,
    fInput := fCalibMJ,
    arrOutput => fCalibMJBuffer);

END_FUNCTION_BLOCK
```


POU: FB_PPM_States
------------------

File: Library/Devices/PPM/FB_PPM_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_PPM_States EXTENDS FB_PositionStateBase_WithPMPS
VAR_INPUT
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_PPM_states;

    stOut: DUT_PositionState;
    stPower: DUT_PositionState;
    stYag1: DUT_PositionState;
    stYag2: DUT_PositionState;

    bStatesLock: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_PPM_States;
END_VAR
VAR
    bPPMInit: BOOL;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 2;
    fOutDelta: LREAL := 2;
    fInVelocity: LREAL := 5;
    fOutVelocity: LREAL := 5;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bPPMInit THEN
    bPPMInit := TRUE;

    stOut.sName := 'OUT';
    stOut.fVelocity := fOutVelocity;
    stOut.fDelta := fOutDelta;
    stOut.fAccel := fAccel;
    stOut.fDecel := fOutDecel;
    stOut.bMoveOk := TRUE;

    stPower.sName := 'POWERMETER';
    stPower.fVelocity := fInVelocity;
    stPower.fDelta := fInDelta;
    stPower.fAccel := fAccel;
    stPower.fDecel := fAccel;
    stPower.bMoveOk := TRUE;

    stYag1.sName := 'YAG1';
    stYag1.fVelocity := fInVelocity;
    stYag1.fDelta := fInDelta;
    stYag1.fAccel := fAccel;
    stYag1.fDecel := fAccel;
    stYag1.bMoveOk := TRUE;

    stYag2.sName := 'YAG2';
    stYag2.fVelocity := fInVelocity;
    stYag2.fDelta := fInDelta;
    stYag2.fAccel := fAccel;
    stYag2.fDecel := fAccel;
    stYag2.bMoveOk := TRUE;

    arrStates[1] := stOut;
    arrStates[2] := stPower;
    arrStates[3] := stYag1;
    arrStates[4] := stYag2;
END_IF

setState := enumSet;
Exec();
enumGet := getState;
enumSet := setState;

END_FUNCTION_BLOCK
```


POU: FB_REF
-----------

File: Library/Devices/REF/FB_REF.TcPOU

```vhdl
FUNCTION_BLOCK FB_REF
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    stIn: DUT_PositionState;
    stOut: DUT_PositionState;
    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_PositionStateInOut_WithPMPS;

    {attribute 'pytmc' := '
        pv: LAS
        io: io
    '}
    fbLaser: FB_REF_Laser;

    bInit: BOOL;
END_VAR
VAR CONSTANT
    bStatesLock: BOOL := FALSE;
    fVelo: LREAL := 10;
    fAccel: LREAL := 10;
    fDelta: LREAL := 2;
END_VAR
IF NOT bInit THEN
    bInit := TRUE;

    stOut.fDelta := fDelta;
    stOut.fVelocity := fVelo;
    stOut.fAccel := fAccel;
    stOut.fDecel := fAccel;
    stOut.bLocked := bStatesLock;
    stOut.bMoveOk := TRUE;

    stIn.fDelta := fDelta;
    stIn.fVelocity := fVelo;
    stIn.fAccel := fAccel;
    stIn.fDecel := fAccel;
    stIn.bLocked := bStatesLock;
    stIn.bMoveOk := TRUE;
END_IF

fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable:=TRUE,
    stOut := stOut,
    stIn := stIn);

fbLaser();

END_FUNCTION_BLOCK
```


POU: FB_REF_Laser
-----------------

File: Library/Devices/REF/FB_REF_Laser.TcPOU

```vhdl
FUNCTION_BLOCK FB_REF_Laser
VAR_INPUT
    bShutdown: BOOL;

    {attribute 'pytmc' := '
        pv: PCT
        io: io
    '}
    fLaserPercent: LREAL;
END_VAR
VAR
    iShutdownINT AT %Q*: INT;
    iLaserINT AT %Q*: INT;

    fbGetLasPercent: FB_AnalogInput;
    fbSetLasPercent: FB_AnalogOutput;
END_VAR
// Send 5V to suppress laser
IF bShutdown THEN
    iShutdownINT := LREAL_TO_INT(EXPT(2, 14));
ELSE
    iShutdownINT := 0;
END_IF

// Limit to 0-5V instead of 10V
fbSetLasPercent(
    fReal:=fLaserPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    iRaw=>iLaserInt);
fbGetLasPercent(
    iRaw:=iLaserInt,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    fReal=>fLaserPercent);

END_FUNCTION_BLOCK
```


POU: FB_SLITS
-------------

File: Library/Devices/SLITS/FB_SLITS.TcPOU

```vhdl
FUNCTION_BLOCK FB_SLITS


END_FUNCTION_BLOCK
ACTION ACT_BLOCK:

END_ACTION
ACTION ACT_CalculatePositions:

END_ACTION
```


POU: FB_SLITS_POWER
-------------------

File: Library/Devices/SLITS/FB_SLITS_POWER.TcPOU

```vhdl
FUNCTION_BLOCK FB_SLITS_POWER EXTENDS FB_SLITS
VAR_IN_OUT
    stTopBlade: DUT_MotionStage;
    stBottomBlade: DUT_MotionStage;
    stNorthBlade: DUT_MotionStage;
    stSouthBlade: DUT_MotionStage;
END_VAR
VAR_INPUT
    {attribute 'pytmc' := '
    pv: GO;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bExecuteMotion:BOOL ;
    {attribute 'pytmc' := '
    pv: PMPS_OK;
    io: i;
    field: ZNAM False
    field: ONAM True
    '}
    bMoveOk:BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
    fbTopBlade: FB_MotionStage;
    fbBottomBlade: FB_MotionStage;
    fbNorthBlade: FB_MotionStage;
    fbSouthBlade: FB_MotionStage;
    fPosTopBlade: LREAL;
    fPosBottomBlade: LREAL;
    fPosNorthBlade: LREAL;
    fPosSouthBlade: LREAL;

    (*Motion Parameters*)
    fSmallDelta: LREAL := 0.01;
    fBigDelta: LREAL := 10;
    fMaxVelocity: LREAL := 0.2;
    fHighAccel: LREAL := 0.8;
    fLowAccel: LREAL := 0.1;

    stTop: DUT_PositionState;
    stBOTTOM: DUT_PositionState;
    stNorth: DUT_PositionState;
    stSouth: DUT_PositionState;

    {attribute 'pytmc' := 'pv: TOP'}
    fbTop: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: BOTTOM'}
    fbBottom: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: NORTH'}
    fbNorth: FB_StatePTPMove;
    {attribute 'pytmc' := 'pv: SOUTH'}
    fbSouth: FB_StatePTPMove;

    (*EPICS pvs*)
    {attribute 'pytmc' := '
    pv: XWID_REQ;
    io: io;
    '}
    rReqApertureSizeX : REAL;
    {attribute 'pytmc' := '
    pv: YWID_REQ;
    io: io;
    '}
    rReqApertureSizeY : REAL;
    {attribute 'pytmc' := '
    pv: XCEN_REQ;
    io: io;
    '}
    rReqCenterX: REAL;
    {attribute 'pytmc' := '
    pv: YCEN_REQ;
    io: io;
    '}
    rReqCenterY: REAL;

    {attribute 'pytmc' := '
    pv: ACTUAL_XWIDTH;
    io: io;
    '}
    rActApertureSizeX : REAL;

    {attribute 'pytmc' := '
    pv: ACTUAL_YWIDTH;
    io: io;
    '}
    rActApertureSizeY : REAL;
    {attribute 'pytmc' := '
    pv: ACTUAL_XCENTER;
    io: io;
    '}
    rActCenterX: REAL;
    {attribute 'pytmc' := '
    pv: ACTUAL_YCENTER;
    io: io;
    '}
    rActCenterY: REAL;

    {attribute 'pytmc' := '
    pv: XCEN_SETZERO;
    io: io;
    '}
    rSetCenterX: REAL;
    {attribute 'pytmc' := '
    pv: YCEN_SETZERO;
    io: io;
    '}
    rSetCenterY: REAL;


    {attribute 'pytmc' := '
    pv: OPEN;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bOpen: BOOL;

    {attribute 'pytmc' := '
    pv: CLOSE;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bClose: BOOL;

    {attribute 'pytmc' := '
    pv: BLOCK;
    io: io;
    field: ZNAM False
    field: ONAM True
    '}
    bBlock: BOOL;


    {attribute 'pytmc' := '
        pv: FSW
    '}
    fbFlowSwitch: FB_XTES_Flowswitch;


    //RTDs
    {attribute 'pytmc' := '
        pv: TOP:RTD:01
    '}
    RTD_TOP_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: TOP:RTD:02
    '}
    RTD_TOP_2: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: BOTTOM:RTD:01
    '}
    RTD_Bottom_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: BOTTOM:RTD:02
    '}
    RTD_Bottom_2: FB_TempSensor;

    {attribute 'pytmc' := '
        pv: NORTH:RTD:01
    '}
    RTD_North_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: NORTH:RTD:02
    '}
    RTD_North_2: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: SOUTH:RTD:01
    '}
    RTD_South_1: FB_TempSensor;
    {attribute 'pytmc' := '
        pv: SOUTH:RTD:02
    '}
    RTD_South_2: FB_TempSensor;

        //Local variables
    bInit: BOOL :=true;
    rTrig_Block: R_TRIG;
    rTrig_Open: R_TRIG;
    rTrig_Close: R_TRIG;

    fPosBlock: LREAL;
    fPosClose: LREAL;
    fPosOpen: LREAL;


END_VAR
//  init the motion stages parameters
IF ( bInit) THEN
    stTopBlade.bHardwareEnable := TRUE;
    stBottomBlade.bHardwareEnable := TRUE;
    stNorthBlade.bHardwareEnable := TRUE;
    stSouthBlade.bHardwareEnable := TRUE;
    stTopBlade.bPowerSelf :=TRUE;
    stBottomBlade.bPowerSelf :=TRUE;
    stNorthBlade.bPowerSelf :=TRUE;
    stSouthBlade.bPowerSelf :=TRUE;
    stTopBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stBottomBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stNorthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
    stSouthBlade.nBrakeMode := ENUM_StageBrakeMode.NO_BRAKE;
END_IF


// Instantiate Function block for all the blades
fbTopBlade(stMotionStage:=stTopBlade);
fbBottomBlade(stMotionStage:=stBottomBlade);
fbNorthBlade(stMotionStage:=stNorthBlade);
fbSouthBlade(stMotionStage:=stSouthBlade);

//SET and GET the requested and Actual values
ACT_CalculatePositions();
//ACT_BLOCK();

// PTP Motion for each blade
stTop.sName := 'Top';
stTop.fPosition := fPosTopBlade;
stTop.fDelta := fSmallDelta;
stTop.fVelocity := fMaxVelocity;
stTop.fAccel := fHighAccel;
stTop.fDecel := fHighAccel;

stBOTTOM.sName := 'Bottom';
stBOTTOM.fPosition := fPosBottomBlade;
stBOTTOM.fDelta := fSmallDelta;
stBOTTOM.fVelocity := fMaxVelocity;
stBOTTOM.fAccel := fHighAccel;
stBOTTOM.fDecel := fHighAccel;

stNorth.sName := 'North';
stNorth.fPosition := fPosNorthBlade;
stNorth.fDelta := fSmallDelta;
stNorth.fVelocity := fMaxVelocity;
stNorth.fAccel := fHighAccel;
stNorth.fDecel := fHighAccel;

stSouth.sName := 'South';
stSouth.fPosition := fPosSouthBlade;
stSouth.fDelta := fSmallDelta;
stSouth.fVelocity := fMaxVelocity;
stSouth.fAccel := fHighAccel;
stSouth.fDecel := fHighAccel;

fbTop.bExecute := fbBottom.bExecute :=fbNorth.bExecute := fbSouth.bExecute := bExecuteMotion;

fbTop(
    stPositionState:=stTop,
    bMoveOk:=bMoveOk,
    stMotionStage:=stTopBlade);

fbBottom(
    stPositionState:=stBOTTOM,
    bMoveOk:=bMoveOk,
    stMotionStage:=stBottomBlade);

fbNorth(
    stPositionState:=stNorth,
    bMoveOk:=bMoveOk,
    stMotionStage:=stNorthBlade);

fbSouth(
    stPositionState:=stSouth,
    bMoveOk:=bMoveOk,
    stMotionStage:=stSouthBlade);


////RTDs
RTD_TOP_1();
RTD_TOP_2();
RTD_Bottom_1();
RTD_Bottom_2();
RTD_North_1();
RTD_North_2();
RTD_South_1();
RTD_South_2();

//Flow Switch
fbFlowSwitch();

END_FUNCTION_BLOCK
ACTION ACT_BLOCK:
rTrig_Block (CLK:= bBlock);
rTrig_Open (CLK:= bOpen);
rTrig_Close (CLK:= bClose);

if (rTrig_Block.Q) THEN
    //BLOCK

    bBlock := false;
END_IF

if (rTrig_Open.Q) THEN


    bOpen := false;
END_IF

if (rTrig_Close.Q) THEN


    bClose := false;
END_IF
END_ACTION
ACTION ACT_CalculatePositions:
//Calculate requested Positions


fPosTopBlade := (rReqApertureSizeY/2) + rReqCenterY;
fPosBottomBlade := (-1*rReqApertureSizeY/2) + rReqCenterY;

fPosNorthBlade := (rReqApertureSizeX/2) + rReqCenterX;
fPosSouthBlade := (-1*rReqApertureSizeX/2) + rReqCenterX;


//Calculate Actual Positions


rActApertureSizeX := ABS(stNorthBlade.stAxisStatus.fActPosition - stSouthBlade.stAxisStatus.fActPosition);

rActApertureSizeY := ABS(stTopBlade.stAxisStatus.fActPosition - stBottomBlade.stAxisStatus.fActPosition);

rActCenterX := ((stNorthBlade.stAxisStatus.fActPosition + stSouthBlade.stAxisStatus.fActPosition)/2);

rActCenterY := ((stTopBlade.stAxisStatus.fActPosition + stBottomBlade.stAxisStatus.fActPosition)/2);



//ZERO BIAS

// Set Y center to zero

// Set X center to zero
END_ACTION
```


POU: FB_WFS
-----------

File: Library/Devices/WFS/FB_WFS.TcPOU

```vhdl
FUNCTION_BLOCK FB_WFS
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    stZStage: DUT_MotionStage;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    stOut: DUT_PositionState;
    stTarget1: DUT_PositionState;
    stTarget2: DUT_PositionState;
    stTarget3: DUT_PositionState;
    stTarget4: DUT_PositionState;
    stTarget5: DUT_PositionState;
    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    fbZStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_WFS_States;

    {attribute 'pytmc' := '
        pv: STC:01
        io: input
    '}
    fbThermoCouple1: FB_TempSensor;

    {attribute 'pytmc' := '
        pv: STC:02
        io: input
    '}
    fbThermoCouple2: FB_TempSensor;
END_VAR
fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbZStage(stMotionStage:=stZStage);
stZStage.bLimitForwardEnable := TRUE;
stZStage.bLimitBackwardEnable := TRUE;
stZStage.bHardwareEnable := TRUE;
stZStage.bPowerSelf := TRUE;
stZStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable := TRUE,
    stOut:=stOut,
    stTarget1:=stTarget1,
    stTarget2:=stTarget2,
    stTarget3:=stTarget3,
    stTarget4:=stTarget4,
    stTarget5:=stTarget5);

fbThermoCouple1();
fbThermoCouple2();

END_FUNCTION_BLOCK
```


POU: FB_WFS_States
------------------

File: Library/Devices/WFS/FB_WFS_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_WFS_States EXTENDS FB_PositionStateBase_WithPMPS
VAR_INPUT
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_WFS_states;

    stOut: DUT_PositionState;
    stTarget1: DUT_PositionState;
    stTarget2: DUT_PositionState;
    stTarget3: DUT_PositionState;
    stTarget4: DUT_PositionState;
    stTarget5: DUT_PositionState;

    bStatesLock: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_WFS_States;
END_VAR
VAR
    bWFSInit: BOOL;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 2;
    fOutDelta: LREAL := 2;
    fInVelocity: LREAL := 5;
    fOutVelocity: LREAL := 5;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bWFSInit THEN
    bWFSInit := TRUE;

    stOut.sName := 'OUT';
    stOut.fVelocity := fOutVelocity;
    stOut.fDelta := fOutDelta;
    stOut.fAccel := fAccel;
    stOut.fDecel := fOutDecel;
    stOut.bMoveOk := TRUE;

    stTarget1.sName := 'TARGET1';
    stTarget1.fVelocity := fInVelocity;
    stTarget1.fDelta := fInDelta;
    stTarget1.fAccel := fAccel;
    stTarget1.fDecel := fAccel;
    stTarget1.bMoveOk := TRUE;

    stTarget2.sName := 'TARGET2';
    stTarget2.fVelocity := fInVelocity;
    stTarget2.fDelta := fInDelta;
    stTarget2.fAccel := fAccel;
    stTarget2.fDecel := fAccel;
    stTarget2.bMoveOk := TRUE;

    stTarget3.sName := 'TARGET3';
    stTarget3.fVelocity := fInVelocity;
    stTarget3.fDelta := fInDelta;
    stTarget3.fAccel := fAccel;
    stTarget3.fDecel := fAccel;
    stTarget3.bMoveOk := TRUE;

    stTarget4.sName := 'TARGET4';
    stTarget4.fVelocity := fInVelocity;
    stTarget4.fDelta := fInDelta;
    stTarget4.fAccel := fAccel;
    stTarget4.fDecel := fAccel;
    stTarget4.bMoveOk := TRUE;

    stTarget5.sName := 'TARGET5';
    stTarget5.fVelocity := fInVelocity;
    stTarget5.fDelta := fInDelta;
    stTarget5.fAccel := fAccel;
    stTarget5.fDecel := fAccel;
    stTarget5.bMoveOk := TRUE;

    arrStates[1] := stOut;
    arrStates[2] := stTarget1;
    arrStates[3] := stTarget2;
    arrStates[4] := stTarget3;
    arrStates[5] := stTarget4;
    arrStates[6] := stTarget5;
END_IF

setState := enumSet;
Exec();
enumGet := getState;
enumSet := setState;

END_FUNCTION_BLOCK
```


POU: FB_XPIM
------------

File: Library/Devices/XPIM/FB_XPIM.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    stZoomStage: DUT_MotionStage;
    stFocusStage: DUT_MotionStage;
    stEl6In: EL6inData22b;
    stEl6Out: EL6OutData22b;
    fbArbiter: FB_Arbiter;
    fbFFHWO: FB_HardwareFFOutput;
END_VAR
VAR_INPUT
    {attribute 'pytmc' := '
        pv: CLZ:LOCK
        io: io
        field: ZNAM Unlocked
        field: ONAM Locked
    '}
    bZoomLock: BOOL;

    {attribute 'pytmc' := '
        pv: CLF:LOCK
        io: io
        field: ZNAM Unlocked
        field: ONAM Locked
    '}
    bFocusLock: BOOL;

    bZoomEndFwd AT %I*: BOOL;
    bZoomEndBwd AT %I*: BOOL;
    bFocusEndFwd AT %I*: BOOL;
    bFocusEndBwd AT %I*: BOOL;

    stOut: DUT_PositionState;
    stYag: DUT_PositionState;
    stDiamond: DUT_PositionState;
    stReticle: DUT_PositionState;

    nTransitionAssertionID: UDINT;
    nUnknownAssertionID: UDINT;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    fbZoom: FB_MotionStage;
    fbFocus: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_XPIM_States;

    {attribute 'pytmc' := '
        pv: MFW
    '}
    fbFilterWheel: FB_XPIM_FilterWheel;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbOpal: FB_XPIM_Opal;

    {attribute 'pytmc' := '
        pv: CIL
    '}
    fbLED: FB_XPIM_LED;

    {attribute 'pytmc' := '
        pv: SFW
    '}
    fbFlowSwitch: FB_XTES_Flowswitch;
END_VAR
fbYStage(stMotionStage:=stYStage);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := FALSE;
// No limit switch at the bottom
stYStage.bLimitBackwardEnable := TRUE;

// Extra lock on lens + lens limits are normally open
fbZoom(stMotionStage:=stZoomStage);
stZoomStage.bHardwareEnable := NOT bZoomLock;
stZoomStage.bPowerSelf := TRUE;
stZoomStage.bLimitForwardEnable := NOT bZoomEndFwd;
stZoomStage.bLimitBackwardEnable := NOT bZoomEndBwd;
stZoomStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;

fbFocus(stMotionStage:=stFocusStage);
stFocusStage.bHardwareEnable := NOT bFocusLock;
stFocusStage.bPowerSelf := TRUE;
stFocusStage.bLimitForwardEnable := NOT bFocusEndFwd;
stFocusStage.bLimitBackwardEnable := NOT bFocusEndBwd;
stFocusStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;

// Set special error message for lens lock
IF stZoomStage.bExecute AND bZoomLock THEN
    IF NOT stZoomStage.bError THEN
        stZoomStage.bError := TRUE;
    END_IF
    stZoomStage.sCustomErrorMessage := 'Zoom lens is locked!';
END_IF
IF stFocusStage.bExecute AND bFocusLock THEN
    IF NOT stFocusStage.bError THEN
        stFocusStage.bError := TRUE;
    END_IF
    stFocusStage.sCustomErrorMessage := 'Focus lens is locked!';
END_IF

fbStates(
    fbArbiter:=fbArbiter,
    fbFFHWO:=fbFFHWO,
    nTransitionAssertionID:=nTransitionAssertionID,
    nUnknownAssertionID:=nUnknownAssertionID,
    stMotionStage:=stYStage,
    bEnable:=TRUE,
    stOut:=stOut,
    stYag:=stYag,
    stDiamond:=stDiamond,
    stReticle:=stReticle);

fbFilterWheel(
    bExecute:=TRUE,
    stIn_El6:=stEl6In,
    stOut_El6:=stEl6Out);

fbOpal();
fbLED(enumXPIM:=fbStates.enumGet);
fbFlowSwitch();

END_FUNCTION_BLOCK
```


POU: FB_XPIM_FilterWheel
------------------------

File: Library/Devices/XPIM/FB_XPIM_FilterWheel.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_FilterWheel
VAR_INPUT
    bExecute: BOOL;

    {attribute 'pytmc' := '
        pv: ERR:RESET
        io: output
    '}
    bResetError: BOOL;

    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    nSetPos: ENUM_XPIM_Filters;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    nGetPos: ENUM_XPIM_Filters;
    bBusy: BOOL;
    bError: BOOL;
    sError: STRING;
    {attribute 'pytmc' := '
        pv: ERR:MSG
        io: input
    '}
    sLastError: STRING;
    sErrorTS: STRING;
END_VAR
VAR_IN_OUT
    stIn_EL6: EL6inData22B;
    stOut_EL6: EL6outData22B;
END_VAR
VAR
    {attribute 'pytmc' := '
        pv: RAW
    '}
    fbCom: FB_EL6_COM;

    nStep: USINT;
    sLastTestCmd: STRING;
    bIsTest: BOOL;
    fbGetTime: NT_GetTime;
    bStopOnErr: BOOL;
END_VAR
fbCom.sSendSuffix := '$R';
fbCom.sRecvSuffix := '$R';

IF bExecute AND nStep = 0 THEN
    IF bResetError OR NOT bError THEN
        nStep := 10;
    END_IF
ELSIF NOT bExecute THEN
    nStep := 0;
END_IF
CASE nStep OF
    0:
        ; // idle
    10:
        // Get position
        bIsTest := FALSE;
        fbCom(sCmd:='pos?',
            bSend:=TRUE,
            stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        nStep := nStep + 10;
    20:
        // Wait for response and set variables
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        IF fbCom.bDone THEN
            bError := FALSE;
            sError := '';
            nGetPos := STRING_TO_USINT(fbCom.sResponse);
            nSetPos := nGetPos;
            nStep := nStep + 10;
            IF nGetPos = 0 THEN
                sError := 'Filter wheel in invalid state';
                bStopOnErr := TRUE;
                nStep := 50;
            END_IF
        END_IF
    30:
        // Wait for a move request
        IF nSetPos <> nGetPos THEN
            fbCom(sCmd:=CONCAT('pos=', INT_TO_STRING(nSetPos)),
                bSend:=TRUE,
                stIn_EL6:=stIn_EL6,
                stOut_EL6:=stOut_EL6);
            nStep := nStep + 10;
            bBusy := TRUE;
        END_IF
    40:
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        // Wait for move to be done
        IF fbCom.bDone THEN
            bBusy := FALSE;
            nStep := 10;
            // Handle setpoint error
            IF fbCom.sResponse = 'Command error CMD_ARG_INVALID$N$R' THEN
                sError := 'Invalid set position';
                nStep := 50;
            END_IF
        END_IF
    50:
        // Set sError and then jump here for standard handling
        sLastError := sError;
        bError := TRUE;
        fbGetTime(NETID:='',
            START:=TRUE);
        nStep := nStep + 10;
    60:
        // Error handling continued
        fbGetTime();
        IF NOT fbGetTime.BUSY THEN
            sErrorTS := SYSTEMTIME_TO_STRING(fbGetTime.TIMESTR);
            fbGetTime.START := FALSE;
            // set bStopOnErr to TRUE if it was a major error
            IF bStopOnErr THEN
                nStep := 0;
            ELSE
                nStep := 10;
            END_IF
            bStopOnErr := FALSE;
        END_IF
END_CASE
// Check for inner comms errors, report to EPICS same way
IF NOT bError AND
    (fbCom.eRecvErrorID <> COMERROR_NOERROR
    OR fbCom.eSendErrorID <> COMERROR_NOERROR
    OR fbCom.eRecvErrorID <> COMERROR_NOERROR) THEN
    sError := 'Serial Communication Error';
    bStopOnErr := TRUE;
    nStep := 50;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_XPIM_LED
----------------

File: Library/Devices/XPIM/FB_XPIM_LED.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_LED
VAR_INPUT
    {attribute 'pytmc' := '
        pv: PWR
        io: io
        field: ZNAM OFF
        field: ONAM ON
    '}
    bLEDPower AT %Q*: BOOL;

    {attribute 'pytmc' := '
        pv: AUTO
        io: io
    '}
    bLEDAuto: BOOL := TRUE;

    {attribute 'pytmc' := '
        pv: CLK:TIMEOUT
        io: io
        field: EGU min
    '}
    fLEDTimeOut: LREAL := 10;

    enumXPIM: ENUM_XPIM_States;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: CLK:REMAINING
        io: io
        field: EGU min
    '}
    fLEDRemaining: LREAL;
END_VAR
VAR
    tonLED: TON;
    enumLastCycle: ENUM_XPIM_States := ENUM_XPIM_States.Unknown;
END_VAR
// If configured, change the LED level automatically
// LED is always (and only) useful at Reticle state
IF bLEDAuto AND enumXPIM <> enumLastCycle THEN
    // Turn on the LED when we get to the Reticle
    IF enumXPIM = ENUM_XPIM_States.Reticle THEN
        bLEDPower := TRUE;
    // Turn off the LED when we stop at any other state
    ELSIF enumXPIM <> ENUM_XPIM_States.Unknown THEN
        bLEDPower := FALSE;
    END_IF
END_IF
enumLastCycle := enumXPIM;

// If configured, start a shutdown timer when LED goes high
IF fLEDTimeOut <> 0 THEN;
    tonLED(IN:=bLEDPower,
           PT:=LREAL_TO_TIME(fLEDTimeOut * 60 * 1000));
    fLEDRemaining := fLEDTimeOut - TIME_TO_LREAL(tonLED.ET) / 60 / 1000;

    IF tonLED.Q THEN
        bLEDPower := FALSE;
    END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: FB_XPIM_Opal
-----------------

File: Library/Devices/XPIM/FB_XPIM_Opal.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_Opal
VAR_INPUT
    {attribute 'pytmc' := '
        pv: PWR
        io: io
        field: ZNAM OFF
        field: ONAM ON
    '}
    bOpalPower AT %Q*: BOOL;
END_VAR
VAR
    bOpalInit: BOOL := FALSE;
END_VAR
// Turn the Opal on by default
IF NOT bOpalInit THEN
    bOpalPower := TRUE;
    bOpalInit := TRUE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_XPIM_States
-------------------

File: Library/Devices/XPIM/FB_XPIM_States.TcPOU

```vhdl
FUNCTION_BLOCK FB_XPIM_States EXTENDS FB_PositionStateBase_WithPMPS
VAR_INPUT
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_XPIM_states;

    stOut: DUT_PositionState;
    stYag: DUT_PositionState;
    stDiamond: DUT_PositionState;
    stReticle: DUT_PositionState;

    bStatesLock: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_XPIM_States;
END_VAR
VAR
    bXPIMInit: BOOL;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 2;
    fOutDelta: LREAL := 2;
    fInVelocity: LREAL := 5;
    fOutVelocity: LREAL := 5;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
IF NOT bXPIMInit THEN
    bXPIMInit := TRUE;

    stOut.sName := 'OUT';
    stOut.fVelocity := fOutVelocity;
    stOut.fDelta := fOutDelta;
    stOut.fAccel := fAccel;
    stOut.fDecel := fOutDecel;
    stOut.bMoveOk := TRUE;

    stYag.sName := 'YAG';
    stYag.fVelocity := fInVelocity;
    stYag.fDelta := fInDelta;
    stYag.fAccel := fAccel;
    stYag.fDecel := fAccel;
    stYag.bMoveOk := TRUE;

    stDiamond.sName := 'DIAMOND';
    stDiamond.fVelocity := fInVelocity;
    stDiamond.fDelta := fInDelta;
    stDiamond.fAccel := fAccel;
    stDiamond.fDecel := fAccel;
    stDiamond.bMoveOk := TRUE;

    stReticle.sName := 'RETICLE';
    stReticle.fVelocity := fInVelocity;
    stReticle.fDelta := fInDelta;
    stReticle.fAccel := fAccel;
    stReticle.fDecel := fAccel;
    stReticle.bMoveOk := TRUE;

    arrStates[1] := stOut;
    arrStates[2] := stYag;
    arrStates[3] := stDiamond;
    arrStates[4] := stReticle;
END_IF

setState := enumSet;
Exec();
enumGet := getState;
enumSet := setState;

END_FUNCTION_BLOCK
```


POU: FB_XTES_Flowswitch
-----------------------

File: Library/POUs/FB_XTES_Flowswitch.TcPOU

```vhdl
FUNCTION_BLOCK FB_XTES_Flowswitch
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: FLOW
        field: ZNAM LOW
        field: ONAM OK
    '}
    bFlowOk AT %I*: BOOL;
END_VAR


END_FUNCTION_BLOCK
```


Symbols
-------


Boxes
-----

NC axes
-------

Links
-----


Pragma lint results
-------------------
```
INFO:pytmc.bin.pragmalint:Total pragmas found: 94 Total linter errors: 0
PLC Project (1): Library
========================


Devices/ATM/ENUM_ATM_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_ATM_States: Declaration - 1 pragmas


Devices/ATM/FB_ATM.TcPOU (TcPlcObject)
--------------------------------------

    - FB_ATM: Declaration - 2 pragmas


Devices/ATM/FB_ATM_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_ATM_States: Declaration - 2 pragmas


Devices/LIC/ENUM_LIC_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_LIC_States: Declaration - 1 pragmas


Devices/LIC/FB_LIC.TcPOU (TcPlcObject)
--------------------------------------

    - FB_LIC: Declaration - 1 pragmas


Devices/LIC/FB_LIC_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_LIC_States: Declaration - 2 pragmas


Devices/PPM/ENUM_PPM_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_PPM_States: Declaration - 1 pragmas


Devices/PPM/FB_PPM.TcPOU (TcPlcObject)
--------------------------------------

    - FB_PPM: Declaration - 5 pragmas


Devices/PPM/FB_PPM_Gige.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_PPM_Gige: Declaration - 2 pragmas


Devices/PPM/FB_PPM_PowerMeter.TcPOU (TcPlcObject)
-------------------------------------------------

    - FB_PPM_PowerMeter: Declaration - 10 pragmas


Devices/PPM/FB_PPM_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_PPM_States: Declaration - 2 pragmas


Devices/REF/FB_REF.TcPOU (TcPlcObject)
--------------------------------------

    - FB_REF: Declaration - 2 pragmas


Devices/REF/FB_REF_Laser.TcPOU (TcPlcObject)
--------------------------------------------

    - FB_REF_Laser: Declaration - 1 pragmas


Devices/SLITS/FB_SLITS_POWER.TcPOU (TcPlcObject)
------------------------------------------------

    - FB_SLITS_POWER: Declaration - 28 pragmas


Devices/WFS/ENUM_WFS_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_WFS_States: Declaration - 1 pragmas


Devices/WFS/FB_WFS.TcPOU (TcPlcObject)
--------------------------------------

    - FB_WFS: Declaration - 3 pragmas


Devices/WFS/FB_WFS_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_WFS_States: Declaration - 2 pragmas


Devices/XPIM/ENUM_XPIM_Filters.TcDUT (TcPlcObject)
--------------------------------------------------

    - ENUM_XPIM_Filters: Declaration - 1 pragmas


Devices/XPIM/ENUM_XPIM_States.TcDUT (TcPlcObject)
-------------------------------------------------

    - ENUM_XPIM_States: Declaration - 1 pragmas


Devices/XPIM/FB_XPIM.TcPOU (TcPlcObject)
----------------------------------------

    - FB_XPIM: Declaration - 7 pragmas


Devices/XPIM/FB_XPIM_FilterWheel.TcPOU (TcPlcObject)
----------------------------------------------------

    - FB_XPIM_FilterWheel: Declaration - 5 pragmas


Devices/XPIM/FB_XPIM_LED.TcPOU (TcPlcObject)
--------------------------------------------

    - FB_XPIM_LED: Declaration - 4 pragmas


Devices/XPIM/FB_XPIM_Opal.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_XPIM_Opal: Declaration - 1 pragmas


Devices/XPIM/FB_XPIM_States.TcPOU (TcPlcObject)
-----------------------------------------------

    - FB_XPIM_States: Declaration - 2 pragmas


POUs/FB_L2SI_Flowmeter.TcPOU (TcPlcObject)
------------------------------------------

    - FB_L2SI_Flowmeter: Declaration - 2 pragmas


POUs/FB_XTES_Flowswitch.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_XTES_Flowswitch: Declaration - 1 pragmas


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

    - Global_Version: Declaration - 4 pragmas

```
